      program main
c
c-------------------------------------------------------------------------------
c
c Language:    Fortran
c
c Author:      Joe Koebbe
c Date:        11/13/2016
c
c Description: This file contains a means for approximating the condition number
c              of a square matrix. The method uses a lu factorization and a
c              loop over one spot vectors to compute the inverse of the matrix.
c              The code includes a matrix generation routine that creates a
c              diagonally dominant matrix. All of the subroutines outside of the
c              code to compute the inverse of the matrix are from previous
c              lectures in the course.
c
c-------------------------------------------------------------------------------
c
      real A(100,100), Ainv(100,100)
      real AInfCondNo, AOneCondNo
      real value
      real matrixOneNorm, matrixInfNorm
c
c set the size of the matrix
c --------------------------
c
      n = 4
c
c generate a test matrix
c ----------------------
c
      print *,'Step 1: generate a matrix for the computation'
      call matrixGenerator(A, n)
      print *,'      : matrix has been generated'
c
c compute the inverse of the matrix
c ---------------------------------
c
      print *,'Step 2: compute the inverse of the matrix'
      call computeAInv(A, Ainv, n)
      print *,'      : inverse of the matrix has been computed'
c
c compute the 1-condition number of the matrix
c --------------------------------------------
c
      print *,'Step 3: compute the norms of the matrix and inverse'
      value1 = matrixOneNorm(A, n)
      value2 = matrixOneNorm(Ainv, n)
      value = value1 * value2
      print *,'One norm of A:                      ', value1
      print *,'One norm of Ainv:                   ', value2
      print *,'The One Condition Number is:        ', value
      print *,' '
      value1 = matrixInfNorm(A, n)
      value2 = matrixInfNorm(Ainv, n)
      value = value1 * value2
      print *,'Infinity Norm of A:                 ', value1
      print *,'Infinity Norm of Ainv:              ', value2
      print *,'The Infinity Condition Number is:   ', value
c
      stop
      end
c
c-------------------------------------------------------------------------------
c
c this method will generate a square diagonally dominant matrix of a given
c size for testing problems in computational linear algebra
c
c-------------------------------------------------------------------------------
c
      subroutine matrixGenerator(A, n)
c
c-------------------------------------------------------------------------------
c
c Language:    Fortran
c
c Author:      Joe Koebbe
c Date:        11/13/2016
c
c Description: This method is used to generated a diagonally dominant matrix for
c              testing algorithms in computational linear algebra. 
c
c Arguments: A, n
c
c Input:  n - the number of rows (or columns) in the matrix generated by the
c             routine
c
c Output: A - the nxn matrix generated by the routine - the matrix will be
c             square and diagonally dominant using a modification along the
c             diagonal
c
c-------------------------------------------------------------------------------
c
c storage and parameters for the generation of values for the matrix
c ------------------------------------------------------------------
c
      real A(100,100)
      int iseed = 17
c
c loop over all entries in the matrix initializing these to uniform random
c values
c ------
c
      do 1 i=1,n
      do 1 j=1,n
         A(i,j) = ran(iseed)
    1 continue
c
c add a sufficient amount to the diagonal of the matrix to ensure diagonal
c dominance of the matrix that is returned by the subroutine
c ----------------------------------------------------------
c
      do 2 i=1,n
         A(i,i) = A(i,i) + 10.0 * n
    2 continue
c
      return
      end
c
c the following is code for solving a linear system of equations using a LU
c factorication
c -------------
c
      subroutine lu(A, n)
      real A(100,100)
c
c loop over the columns for the reduction
c ---------------------------------------
c
      do 1 k=1,n-1
c
c loop over the rows below the current pivot row
c ----------------------------------------------
c
         do 2 i=k+1,n
c
c compute the factor needed to eliminate the current entry in the matrix below
c the pivot row
c -------------
c
            factor = A(i,k) / A(k,k)
c
c loop over the rest of the columns in the elimination below the pivot row
c ------------------------------------------------------------------------
c
            do 3 j=k+1,n
               A(i,j) = A(i,j) - factor * A(k,j)
    3       continue
c
c save the elimination factor in the matrix to form the lower triangular part
c of the lu-factorization
c -----------------------
c
            A(i,k) = factor
c
    2    continue
c
    1 continue
c
      return
      end
c
c the following code implements forward substitution for the solution of lower
c triangular systems
c ------------------
c
      subroutine fsub(A, b, n, y)
      real A(100,100), b(100), y(100)
c
c start in the first row and compute the first entry of the solution vector
c -------------------------------------------------------------------------
c
      y(1) = b(1)
c
c loop over the rest of the rows in the matrix
c --------------------------------------------
c
      do 1 i=2,n
c
c initialize the solution vector in the current row to the right hand side value
c ------------------------------------------------------------------------------
c
         y(i) = b(i)
c
c loop over the columns in the lower triangular part to compute the solution
c --------------------------------------------------------------------------
c
         do 2 j=1,i-1
            y(i) = y(i) - A(i,j) * y(j)
    2    continue
c
    1 continue
c
      return
      end
c
c the following code implements back substitution for the solution of an upper
c triangular system
c -----------------
c
      subroutine bsub(A, y, n, x)
      real A(100,100), y(100), x(100)
c
c start with the last entry in the solution vector and divide by the diagonal
c entry in the matrix
c -------------------
c
      x(n) = y(n) / A(n,n)
c
c loop backwards through the rows of the system
c ---------------------------------------------
c
      do 1 i=n-1,1,-1
c
c loop over the columns in the upper triangular matrix modifying the current
c entry in the solution vector
c ----------------------------
c
         do 2 j=1,i-1
            x(i) = y(i) - A(i,j) * y(j)
    2    continue
c
c divide by the diagonal entry for the upper triangular system of equations
c -------------------------------------------------------------------------
c
         x(i) = x(i) / A(i,i)
c
    1 continue
c
      return
      end
c
c the following routine will compute the inverse of a matrix using the lu
c factorization algorithm
c -----------------------
c
      subroutine computeAInv(A, Ainv, n)
      real A(100,100), Ainv(100,100), onespot(100)
      real xcol(100), ycol(100)
c
c compute the lu-factorization of the matrix
c ------------------------------------------
c
      print *, '      Step 2a.: compute the lu factorization'
      call lu(A, n)
      print *, '              : done with the lu factorization'
c
c compute solutions of the systems of equations generated by each of the one
c spot vectors using the lu-factorization
c ---------------------------------------
c
      print *, '      Step 2b.: loop over the one spot vectors'
      do 1 k=1,n
c
c initialize the next one-spot vector
c -----------------------------------
c
         do 2 i=1,n
            onespot(i) = 0.0
    2    continue
         onespot(k) = 1.0
c
c perform forward substitution on the one-spot vector linear system of equations
c ------------------------------------------------------------------------------
c
         call fsub(A, onespot, n, ycol)
c
c perform back substitution on the one-spot vector linear system of equations
c ---------------------------------------------------------------------------
c
         call bsub(A, ycol, n, xcol)
c
c store the result into the storage given for the inverse of the matrix
c ---------------------------------------------------------------------
c
         do 3 i=1,n
            Ainv(i,k) = xcol(i)
    3    continue
c
c end of the one-spot lecture loop
c --------------------------------
c
    1 continue
      print *, '              : done with one-spot vector loop'
c
      return
      end
c
c the following is a routine used to compute the infinity matrix norm of a
c square matrix
c -------------
c
      real function matrixInfNorm(A, n)
      real A(100,100), sum, anrm
c
c initialize the temporary norm value
c -----------------------------------
c
      anrm = 0.0
c
c loop over the rows of the matrix
c --------------------------------
c
      do 1 i=1,n
c
c initialize the current absolute row sum value
c ---------------------------------------------
c
         sum = 0.0
c
c loop over the columns of the matrix adding the current absolute values of the
c entries
c -------
c
         do 2 j=1,n
            sum = sum + abs(A(i,j))
    2    continue
c
c test to see if the current row sum is the largest
c -------------------------------------------------
c
         if(sum .gt. anrm) anrm = sum
c
    1 continue
c
c set the value determine in the loops to the function name - this is a fortran
c thing with functions
c --------------------
c
      matrixInfNorm = anrm
c
      return
      end
c
c the following is a code for computing the 1-matrix norm of a square matrix
c --------------------------------------------------------------------------
c
      real function matrixOneNorm(A, n)
      real A(100,100), sum, anrm
c
c initialize the value of the current absolute column sum
c -------------------------------------------------------
c
      anrm = 0.0
c
c loop over the columns of the matrix
c -----------------------------------
c
      do 1 j=1,n
c
c initialize the current absolute column sum to zero
c --------------------------------------------------
c 
         sum = 0.0
c
c loop over the entries in the current column adding the absolute value of the
c entries
c -------
c
         do 2 i=1,n
            sum = sum + abs(A(i,j))
    2    continue
c
c test to see if the current column sum is the largest
c ----------------------------------------------------
c
         if(sum .gt. anrm) anrm = sum
c
    1 continue
c
c set the value determine in the loops to the function name - this is a fortran
c thing with functions
c --------------------
c
      matrixOneNorm = anrm
c
      return
      end
c
c-------------------------------------------------------------------------------
c
c This is a utility routine for printing out a matrix. The matrix is printed
c by entry in starting from the first row and proceeding row by row. This was
c written to aid in debugging the code for the current problem and does not
c appear in the body of the code.
c
c-------------------------------------------------------------------------------
c
      subroutine matprt(A, n)
      real A(100,100)
      do 1 i=1,n
      do 1 j=1,n
         print *,'A(',i,', ',j,') = ', A(i,j)
    1 continue
      return
      end
 Step 1: generate a matrix for the computation
       : matrix has been generated
 Step 2: compute the inverse of the matrix
       Step 2a.: compute the lu factorization
               : done with the lu factorization
       Step 2b.: loop over the one spot vectors
               : done with one-spot vector loop
       : inverse of the matrix has been computed
 Step 3: compute the norms of the matrix and inverse
 One norm of A:                         40.5450134    
 One norm of Ainv:                      2.51688715E-02
 The One Condition Number is:           1.02047229    
  
 Infinity Norm of A:                    40.5478058    
 Infinity Norm of Ainv:                 2.51691602E-02
 The Infinity Condition Number is:      1.02055418    
